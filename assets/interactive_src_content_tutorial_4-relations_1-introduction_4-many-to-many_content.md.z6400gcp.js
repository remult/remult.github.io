import{_ as e,c as a,o as t,a5 as n}from"./chunks/framework.C7bC4sbb.js";const o="/assets/diagram.BFoeWk7k.png",D=JSON.parse('{"title":"Many to Many","description":"","frontmatter":{"type":"lesson","title":"Many to Many","template":"relations-with-products","focus":"/shared/ProductInOrder.ts"},"headers":[],"relativePath":"interactive/src/content/tutorial/4-relations/1-introduction/4-many-to-many/content.md","filePath":"interactive/src/content/tutorial/4-relations/1-introduction/4-many-to-many/content.md","lastUpdated":1729692427000}'),s={name:"interactive/src/content/tutorial/4-relations/1-introduction/4-many-to-many/content.md"},i=n('<h1 id="many-to-many-relations" tabindex="-1">Many-to-Many Relations <a class="header-anchor" href="#many-to-many-relations" aria-label="Permalink to &quot;Many-to-Many Relations&quot;">​</a></h1><p>In some applications, an entity might need to have a relationship with multiple entities from another table, and vice versa. In our case, an <code>Order</code> can contain many <code>Products</code>, and the same <code>Product</code> can appear in many <code>Orders</code>. This is a classic <strong>many-to-many</strong> relationship.</p><p>To implement this relationship, we use an intermediate entity called <code>ProductInOrder</code>, which serves as a bridge between <code>Order</code> and <code>Product</code>. This intermediate entity stores the association between an order and a product, along with additional details that pertain to the relationship, such as quantity or price, if needed.</p><p><img src="'+o+`" alt="Many to Many relation"></p><h3 id="defining-the-many-to-many-relation" tabindex="-1">Defining the Many-to-Many Relation <a class="header-anchor" href="#defining-the-many-to-many-relation" aria-label="Permalink to &quot;Defining the Many-to-Many Relation&quot;">​</a></h3><p>Let&#39;s define the <code>ProductInOrder</code> entity, which establishes the many-to-many relation between <code>Order</code> and <code>Product</code>.</p><div class="language-file:/shared/ProductInOrder.ts"><button title="Copy Code" class="copy"></button><span class="lang">file:/shared/ProductInOrder.ts</span><pre class="shiki dark-plus vp-code" tabindex="0"><code><span class="line"><span></span></span></code></pre></div><h3 id="key-points" tabindex="-1">Key Points <a class="header-anchor" href="#key-points" aria-label="Permalink to &quot;Key Points&quot;">​</a></h3><ol><li><p><strong>Composite Primary Key</strong>:<br> We define the composite primary key using both <code>orderId</code> and <code>productId</code> (<code>id: [&#39;orderId&#39;, &#39;productId&#39;]</code>). This ensures that the combination of these two fields uniquely identifies each record in <code>ProductInOrder</code>. Using a composite key improves performance when querying or joining tables because it provides a direct and efficient way to locate specific rows.</p></li><li><p><strong>Relation to <code>Product</code></strong>:<br> The <code>@Relations.toOne()</code> decorator establishes a relationship between <code>ProductInOrder</code> and the <code>Product</code> entity. This allows us to easily fetch the related <code>Product</code> information (such as the name or price) when querying <code>ProductInOrder</code>.</p></li></ol><h3 id="defining-the-order-entity" tabindex="-1">Defining the <code>Order</code> Entity <a class="header-anchor" href="#defining-the-order-entity" aria-label="Permalink to &quot;Defining the \`Order\` Entity&quot;">​</a></h3><p>In the <code>Order</code> entity, we use a <code>toMany</code> relation to link each order to its products through the <code>ProductInOrder</code> entity. This allows us to keep track of all the products in a particular order.</p><div class="language-file:/shared/Order.ts"><button title="Copy Code" class="copy"></button><span class="lang">file:/shared/Order.ts</span><pre class="shiki dark-plus vp-code" tabindex="0"><code><span class="line highlighted"><span></span></span></code></pre></div><h3 id="querying-the-data" tabindex="-1">Querying the Data <a class="header-anchor" href="#querying-the-data" aria-label="Permalink to &quot;Querying the Data&quot;">​</a></h3><p>When you want to fetch the data, including the related products, you can use the <code>include</code> option to fetch not only the <code>ProductInOrder</code> records but also the corresponding <code>Product</code> details.</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dark-plus vp-code" tabindex="0"><code><span class="line"><span style="color:#DCDCAA;">repo</span><span style="color:#D4D4D4;">(</span><span style="color:#9CDCFE;">Customer</span><span style="color:#D4D4D4;">).</span><span style="color:#DCDCAA;">find</span><span style="color:#D4D4D4;">({</span></span>
<span class="line"><span style="color:#9CDCFE;">  include:</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#9CDCFE;">    orders:</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#9CDCFE;">      include:</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#9CDCFE;">        products:</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#9CDCFE;">          include:</span><span style="color:#D4D4D4;"> {</span></span>
<span class="line"><span style="color:#9CDCFE;">            product:</span><span style="color:#569CD6;"> true</span><span style="color:#D4D4D4;">, </span><span style="color:#6A9955;">// Fetch product details such as name, price, etc.</span></span>
<span class="line"><span style="color:#D4D4D4;">          },</span></span>
<span class="line"><span style="color:#D4D4D4;">        },</span></span>
<span class="line"><span style="color:#D4D4D4;">      },</span></span>
<span class="line"><span style="color:#D4D4D4;">    },</span></span>
<span class="line"><span style="color:#D4D4D4;">  },</span></span>
<span class="line"><span style="color:#D4D4D4;">})</span></span></code></pre></div><h3 id="why-not-use-a-built-in-many-to-many-feature" tabindex="-1">Why Not Use a Built-in Many-to-Many Feature? <a class="header-anchor" href="#why-not-use-a-built-in-many-to-many-feature" aria-label="Permalink to &quot;Why Not Use a Built-in Many-to-Many Feature?&quot;">​</a></h3><p>A natural question arises: why not create a built-in many-to-many relation directly between <code>Order</code> and <code>Product</code> without an intermediate table?</p><p>The reason is that most <strong>many-to-many relationships</strong> in real-world applications are not that simple. Typically, you will need to store additional information about the relationship itself, such as <strong>quantity</strong>, <strong>pricing</strong>, <strong>discounts</strong>, or <strong>status</strong>. By using an intermediate entity like <code>ProductInOrder</code>, you have the flexibility to store these additional attributes alongside the relationship. This approach is much more versatile and better suited to real-world use cases than a basic many-to-many relation, which can be too limited for most scenarios.</p><h3 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h3><p>In this lesson, we&#39;ve learned how to model many-to-many relationships using an intermediate table. By creating the <code>ProductInOrder</code> entity, we&#39;ve enabled a flexible many-to-many relationship between <code>Order</code> and <code>Product</code>. This approach allows us to include additional fields, such as quantity, in the relationship while maintaining optimal performance through the use of composite keys.</p>`,20),r=[i];function c(d,l,p,h,u,y){return t(),a("div",null,r)}const g=e(s,[["render",c]]);export{D as __pageData,g as default};
