import{_ as e,c as t,o,a5 as a}from"./chunks/framework.C7bC4sbb.js";const y=JSON.parse('{"title":"Id Based Relations","description":"","frontmatter":{"type":"lesson","title":"Id Based Relations","template":"relations","focus":"/shared/Order.ts"},"headers":[],"relativePath":"interactive/src/content/tutorial/4-relations/1-introduction/3-id-based-relations/content.md","filePath":"interactive/src/content/tutorial/4-relations/1-introduction/3-id-based-relations/content.md","lastUpdated":1729692427000}'),n={name:"interactive/src/content/tutorial/4-relations/1-introduction/3-id-based-relations/content.md"},s=a(`<h1 id="id-based-relations" tabindex="-1">ID-Based Relations <a class="header-anchor" href="#id-based-relations" aria-label="Permalink to &quot;ID-Based Relations&quot;">​</a></h1><p>ID-based relations provide more control over how related entities are managed. By explicitly including the foreign key (such as <code>customerId</code>) in the entity, you gain more flexibility and can optimize performance by reducing the need to load the related entity in some cases.</p><h2 id="defining-an-id-based-relation" tabindex="-1">Defining an ID-Based Relation <a class="header-anchor" href="#defining-an-id-based-relation" aria-label="Permalink to &quot;Defining an ID-Based Relation&quot;">​</a></h2><p>In the <code>Order</code> entity, we add a <code>customerId</code> field to store the ID of the related <code>Customer</code>. We then reference this field in the <code>@Relations.toOne</code> decorator to establish the relationship between <code>Order</code> and <code>Customer</code>.</p><p>It&#39;s important to use the correct type arguments, <code>&lt;Order, Customer&gt;</code>, to ensure proper type checking for this relation.</p><div class="language-file:/shared/Order.ts"><button title="Copy Code" class="copy"></button><span class="lang">file:/shared/Order.ts</span><pre class="shiki dark-plus vp-code" tabindex="0"><code><span class="line highlighted"><span></span></span></code></pre></div><p>In this setup, the <code>customerId</code> field holds the reference to the customer, and the <code>@Relations.toOne</code> decorator connects the <code>Order</code> entity to the <code>Customer</code> entity.</p><h2 id="defining-the-inverse-relation" tabindex="-1">Defining the Inverse Relation <a class="header-anchor" href="#defining-the-inverse-relation" aria-label="Permalink to &quot;Defining the Inverse Relation&quot;">​</a></h2><p>On the <code>Customer</code> entity, we define the inverse of the relation using <code>@Relations.toMany</code>. This decorator links a <code>Customer</code> to multiple <code>Order</code> records, allowing us to retrieve all orders related to a specific customer.</p><div class="language-file:/shared/Customer.ts"><button title="Copy Code" class="copy"></button><span class="lang">file:/shared/Customer.ts</span><pre class="shiki dark-plus vp-code" tabindex="0"><code><span class="line highlighted"><span></span></span></code></pre></div><p>Now, the <code>Customer</code> entity has an <code>orders</code> array, representing all the orders associated with that customer.</p><h2 id="try-it-out" tabindex="-1">Try it out <a class="header-anchor" href="#try-it-out" aria-label="Permalink to &quot;Try it out&quot;">​</a></h2><p>Check out the output and see that the <code>customerId</code> is included even if you do not explicitly include the relation. This gives you the flexibility to work directly with the ID without always needing to load the related entity.</p><h2 id="working-with-existing-data" tabindex="-1">Working with Existing Data <a class="header-anchor" href="#working-with-existing-data" aria-label="Permalink to &quot;Working with Existing Data&quot;">​</a></h2><p>If you already have existing data in your database where the foreign key column is named <code>customer</code>, but you want to use <code>customerId</code> in your code, you can use the <code>dbName</code> property to map the <code>customerId</code> field to the <code>customer</code> column in the database.</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki dark-plus vp-code" tabindex="0"><code><span class="line"><span style="color:#D4D4D4;">@</span><span style="color:#9CDCFE;">Fields</span><span style="color:#D4D4D4;">.</span><span style="color:#DCDCAA;">integer</span><span style="color:#D4D4D4;">({ </span><span style="color:#9CDCFE;">dbName:</span><span style="color:#CE9178;"> &#39;customer&#39;</span><span style="color:#D4D4D4;"> })</span></span>
<span class="line"><span style="color:#9CDCFE;">customerId</span><span style="color:#D4D4D4;"> = </span><span style="color:#B5CEA8;">0</span></span></code></pre></div><p>This ensures that your code uses <code>customerId</code> while mapping it correctly to the <code>customer</code> column in the database, allowing for seamless integration with existing data.</p><hr><p>By using ID-based relations, you have greater control over your data models and can optimize performance by limiting unnecessary entity loading. This approach also provides a clean and efficient way to manage relations in your Remult applications.</p><hr><p>Let me know if this works!</p>`,21),i=[s];function r(d,c,l,p,h,u){return o(),t("div",null,i)}const g=e(n,[["render",r]]);export{y as __pageData,g as default};
